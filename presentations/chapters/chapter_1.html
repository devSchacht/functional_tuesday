<!doctype html>
<html lang="en">
	<head>
	<meta charset="utf-8">

	<title>f(вторник): введение</title>

	<meta name="description" content="Цикл статей о функциональном программировании в JavaScript">
	<meta name="author" content="Роман Пономарев, Вадим Яловенко">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<link rel="stylesheet" href="../css/reveal.min.css">
	<link rel="stylesheet" href="../css/theme/devschacht.min.css" id="theme">
	<link rel="stylesheet" href="../lib/css/zenburn.css">

	<script>
		var link = document.createElement( 'link' );
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match( /print-pdf/gi ) ? '..css/print/pdf.css' : '../css/print/paper.css';
		document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>
</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1><i>f </i>(вторник)</h1>
					<h3>Введение</h3>
					<p><small><a href="https://github.com/devSchacht">devSchacht</a></small></p>
					<aside class="notes">
						Привет! Это первая встреча функционального вторника и сегодня поговорим об основных столпах функционального программирования: декларативности, иммутабельности, функциях высшего порядка - обо всем этом и даже больше. Что ж... начнем
					</aside>
				</section>
				<section>
					<section>
						<h2>Понятие функции <br/><small>(математическое)</small></h2>
						<h6>- правило <code>f</code>, по которому каждому элементу <code>x</code> множества <code>X</code> ставится в зависимость единственный элемент <code>y</code> множества <code>Y</code></h6>
						<aside class="notes">
							Конечно же, как следует из названия, в корне функционального программирования лежит функция - понятие, пришедшее к нам из математики. В математике функция определяется следующим образом: правило f, по которому каждому элементу x множества X ставится в зависимость единственный элемент y множества Y.
						</aside>
					</section>
					<section>
						<h2>Или проще...</h2>
						<h6>- закон отображения множества <code>X</code> на множество <code>Y</code></h6>
						<aside class="notes">
							Или проще: закон отображения множества X на множество Y
						</aside>
					</section>
					<section>
						<h2>И вы туда же?</h2>
						<h6 class="fragment">Да..!</h6>
						<aside class="notes">
							Проще не стало? Тогда вы по адресу: в функциональном программировании такие определения не редкость. Сейчас разберемся.
						</aside>
					</section>
					<section>
						<h2>Сейчас разберемся</h2>
						<aside class="notes">
							Сейчас разберемся
						</aside>
					</section>
					<section>
						<h2>Зависимости</h2>
						<img src="../img/throw.jpg" />
						<aside class="notes">
							В определении прозвучал термин зависимость - когда один элемент ставится в зависимость от другого элемента по определенному правилу. Хотите пример? Представьте, что вы бросаете камень. Вы абсолютно уверены, что дальность полета зависит от силы броска. Это общий закон. Другими словами: дальность полета есть функция силы броска.
						</aside>
					</section>
					<section>
						<h1>y = <i>f</i> (x)</h1>
						<aside class="notes">
							Представить такие отношения можно следующим образом: y = f(x). Если какая-то величина y зависит от другой величины x, говорят, что величина y есть функция величины x.
							Конечно, камень бросить можно и без функции. Но зная закон зависимости, вы знаете, что нужно сделать сейчас, чтобы получить нужный результат потом. Если вы просто бросаете камень ради развлечения, то заранее знать результат броска вам не требуется, но потребуется, если захочется узнать, куда он попадет.
						</aside>
					</section>
					<section data-background="../img/throw1.gif">
						<aside class="notes">
							Этому парню точно требовалось знать результат заранее.
						</aside>
					</section>
					<section>
						<h1>y = <i>f</i> (x)</h1>
						<aside class="notes">
							Вернемся еще раз к нашей функции.

							В нашем выражении слева стоит y. Это и есть функция. Под этим символом скрывается некая любая величина. Это может быть время, температура, пройденный путь, сила тока, зарплата - все, что угодно. Математике без разницы. y еще называется зависимой переменной.

							Справа мы видим x в скобочках. Под x тоже может скрываться любая величина. x на этом месте (в скобочках) называется независимой переменной. Еще одно название для x - аргумент функции.

							Также у нас есть символ f. Под ним скрываются все действия над x, какие только можно представить.

							В этой записи важны не столько символы, сколько скобочки - (). Именно они показывают, что и от чего зависит. Символы могут быть любые другие: g, p, t, s и так далее.
						</aside>
					</section>
					<section data-background="../img/throw.gif">
						<aside class="notes">
							Когда вы все это знаете, вы бросаете камни вот так.
						</aside>
					</section>
					<section>
						<img src="../img/tourists.png" style="width: 450px;" />
						<aside class="notes">
							Теперь решим одну математическую задачку. Предположим, мы едем на автомобиле со средней скоростью 80 км/час. Смотрим на карту и пытаемся оценить, где мы будем через два часа.
						</aside>
					</section>
					<section>
						<h1>S = V·t</h1>
						<aside class="notes">
							Мы знаем закон, что пройденный путь S равен скорости V, умноженной на время t: S = V·t.
						</aside>
					</section>
					<section>
						<h1>S = 80·t</h1>
						<aside class="notes">
							Для нашей скорости 80 км/час формула становится такой: S = 80·t. Через два часа мы проедем 80·2 = 160 километров. Таким образом, между временем и расстоянием существует связь.
						</aside>
					</section>
					<section>
						<h1>y = <i>f</i> (x)</h1>
						<aside class="notes">
							Эту связь можно выразить знакомой нам функцией y = f(x). Под y в нашем случае скрывается путь S. Это зависимая переменная, она зависит от времени. Под x скрывается время t. Это независимая переменная, потому что мы сами ее задаем и функция сработает при любом ее значении. А под символом f в нашей функции скрывается действие - умножение на 80! Это закон нашего конкретного случая, по которому время t превращается в путь S.
						</aside>
					</section>
					<section>
						<h1>S = <i>f</i> (t)</h1>
						<aside class="notes">
							Используя наши символы, можно записать функцию S = f(t). Она означает, что путь как-то зависит от времени. Это общая функция, для любого движения.

							Мы много повторяем термины зависимость, связь, закон, правило - все они объединяются в понятии функции, квинтэссенция которой - взаимосвязь неких переменных величин.
						</aside>
					</section>
					<section>
						<h3>А о программировании будет?</h3>
						<aside class="notes">
							Вы, конечно же, уже задаетесь этим вопросом.
						</aside>
					</section>
					<section data-background="../img/prog.gif"></section>
					<section>
						<h2>Будет!</h2>
						<h6 class="fragment"><strike>(куда же без него)</strike></h6>
						<aside class="notes">
							Будет, куда же без него!
						</aside>
					</section>
					<section>
<pre><code>const multiplyByFive = (x) => 5 * x;

const y = multiplyByFive(4);

// y === 20;</code></pre>
						<ul>
							<li class="fragment"><code>y</code> - зависимая переменная, наша функция</li>
							<li class="fragment"><code>x</code> - независимая переменная или аргумент</li>
							<li class="fragment"><code>multiply</code> - наша f - набор действий, которые нужно произвести над переданным <code>x</code> для получения <code>y</code></li>
						</ul>
						<aside class="notes">
							Рассмотрим функцию multiplyByFive. Она принимает аргумент x и умножает его на 5. Для x = 4 результат будет 20. В математическом понимании:
						</aside>
					</section>
					<section>
						<h3>Функция <br/><small>в математическом понимании:</small></h3>
						<ol>
							<li class="fragment">Получает переменную</li>
							<li class="fragment">Совершает над ней действия</li>
							<li class="fragment">Возвращает переменную</li>
						</ol>
						<aside class="notes">
							По факту функция в математическом понимании делает следующее:
						</aside>
					</section>
					<section>
						<h2>И ничего больше!</h2>
						<p class="fragment"><small>(просто и понятно, к этому стоит стремиться и в программировании)</small></p>
						<aside class="notes">
							И ничего больше! Просто и понятно. К этому стоит стремиться и в программировании!
						</aside>
					</section>
					<section>
						<h2>Понятие функции <br/><small>(программирование)</small></h2>
						<h6 class="fragment">- фрагмент программного кода, к которому можно обратиться из другого места программы</h6>
						<aside class="notes">
							Однако, к сожалению, общее понятие функции в программировании звучит следующим образом: фрагмент программного кода, к которому можно обратиться из другого места программы. Это определение допускает слишком много вольностей (о чем далее)
						</aside>
					</section>
				</section>
				<section>
					<section>
						<h2>Чистая функция</h2>
						<ul>
							<li class="fragment">принимает аргументы</li>
							<li class="fragment">при одних и тех же аргументах производит одинаковый результат</li>
							<li class="fragment">основывается только на внутреннем состоянии и не изменяет внешнее</li>
							<li class="fragment">не производит побочных эффектов</li>
							<li class="fragment">не может вызывать нечистые функции</li>
						</ul>
						<aside class="notes">
							Чистая функция - это функция, которая при одинаковых аргументах всегда возвращает одни и те же значения и не имеет видимых побочных эффектов. Функция является чистой, если:
						</aside>
					</section>
					<section>
						<h6>Чистая функция</h6>
<pre><code>const multiplyByFive = (x) => 5 * x;

const y = multiplyByFive(4);

// y === 20;</code></pre>
						<aside class="notes">
							Если посмотреть на уже знакомую нам функцию multiplyByFive, выражающую собой функцию в математическом понимании, то она же является чистой функцией:
						</aside>
					</section>
					<section>
						<h6>Нечистая функция</h6>
<pre><code>const multiplyByFive = () => x * 5;

const x = 4;
const y = multiplyByFive();

// y === 20;</code></pre>
						<aside class="notes">
							Примером нечистой функции может служить этот код, написанный без оглядки на математическое понимании функции, а так, как нам позволяет писать JavaScript. Что изменилось? Мы всего лишь перестали передавать аргумент. Это нарушает один из принципов чистой функции - принимать аргументы. При таком варианте стабильность нашего кода значительно ниже.
						</aside>
					</section>
					<section>
						<h6>Нечистая функция</h6>
<pre><code>let y;

const multiplyByFive = () => {
	y = 5 * x;
};

const x = 4;
multiplyByFive();

// y === 20;</code></pre>
						<aside class="notes">
							Можно рассмотреть еще одну нечистую вариацию функции multiplyByFive.
							Здесь нарушены практически все принципы чистой функции. Этот код сложно понимать и невозможно поддерживать, так как логика написана запутанно и любое вмешательство может привести к неожиданным последствиям.
						</aside>
					</section>
					<section>
						<h4>Математическая функция != JavaScript функция</h4>
						<aside class="notes">
							Таким образом, функция в математическом понимании является чистой, но она не тождественная JavaScript функции.
						</aside>
					</section>
					<section>
						<h4>Мы же хотим</h4>
					</section>
					<section>
						<h4>Математическая функция == JavaScript функция</h4>
						<aside class="notes">
							Следовательно, чтобы в JavaScript получить чистую функцию, нам необходимо писать функции в их математическом понимании.
						</aside>
					</section>
					<section>
						<h4>Следовательно нам нужно</h4>
					</section>
					<section>
						<h4>JavaScript функция == Чистая функция</h4>
						<aside class="notes">
							Отличие функции в математическом понимании от JavaScript функции заключается в том, что функции в JavaScript могут опираться не только на аргументы, но и на состояние внешних переменных и изменять его, производя побочные эффекты. Это позволяет писать код быстрее и проще, но излишняя гибкость и возможности, которые дает JavaScript, могут привести к проблемам в будущем.
						</aside>
					</section>
					<section data-background="../img/boys.gif">
						<aside class="notes">
							Написание и использование нечистых функций стоит избегать и по возможности всегда работать только с чистыми функциями, чтобы не оказывать влияние на окружения и при одинаковых входных данных всегда получать одинаковый, как парни в глазах девушек, результат.
						</aside>
					</section>
				</section>
				<section>
					<section>
						<h2>Побочные эффекты</h2>
<pre><code>const multiplyByFive = () => {
	y = x * 5;
};

const x = 4;
multiplyByFive();

// y === 20;</code></pre>
						<aside class="notes">
							Одним из нарушенных принципов чистой функции было наличие побочного эффекта. Побочный эффект - ситуация, когда функция или выражение изменяет состояние вне своего контекста. Примерами побочных эффектов могут служить: вызов API, манипулирование DOM, вывод alert, запись в базу данных и так далее. Если функция производит побочные эффекты, она считается нечистой. Такие функции менее предсказуемы и их труднее тестировать, поскольку они приводят к изменениям вне их локальной области видимости.

							Полностью избежать побочных эффектов не получится: без них программа или скрипт попросту не сможет ни на что повлиять. Но работа с побочными эффектами должна быть контролируемой и осознанной. Иначе однажды все закончится выстрелом себе в ногу.
						</aside>
					</section>
					<section data-background="../img/backet.gif"></section>
				</section>
				<section>
					<section>
						<h2>Состояние</h2>
						<h6>— это информация, к которой программа имеет доступ и с которой может работать в определенный момент времени</h6>
						<aside class="notes">
							Что такое состояние, на который повлиял побочный эффект? Состояние - это информация, к которой программа имеет доступ и с которой может работать в определенный момент времени. Это могут быть данные, хранящиеся в памяти, порты ввода/вывода, базы данных и другое.
						</aside>
					</section>
					<section>
						<h2>С состоянием</h2>
<pre><code>var number = 1;

function increment() {
  return number++;
}

// глобальная переменная изменяется: number = 2
increment();</code></pre>
						<aside class="notes">
							Программы, приложения или компоненты с состоянием хранят в памяти данные о текущем состоянии. Они могут изменять состояние, а также имеют доступ к его истории.
						</aside>
					</section>
					<section>
						<h2>Без состояния</h2>
<pre><code>var number = 1;

function increment(n) {
  return n + 1;
}

// глобальная переменная НЕ изменяется: возвращает 2
increment(number);</code></pre>
						<aside class="notes">
							Функции или компоненты без состояния выполняют задачи, словно каждый раз их запускают впервые. Они не ссылаются или не используют в своем исполнении раннее созданные данные. Отсутствие состояния обеспечивает ссылочную прозрачность (любое выражение можно заменить его значением). Функции зависят только от их аргументов и не нуждаются в знании чего-либо вне их области видимости. Им не нужно знать весь ваш план.
						</aside>
					</section>
					<section data-background="../img/joker.gif">
						<aside class="notes">
							Управление состоянием важно для любого сложного приложения. Функции или компоненты с состоянием изменяют состояние и его историю, их труднее тестировать и отлаживать. Функции без состояния полагаются только на свои входные данные для создания данных выходных. Программа без состояния возвращает новое состояние, а не модифицирует существующее состояние.
						</aside>
					</section>
				</section>
				<section>
					<section>
						<h2>Неизменяемость</h2>
						<h6 class="fragment"> - ключевая особенность функционального программирования</h6>
						<aside class="notes">
							Неизменяемость - ключевая особенность функционального программирования.
						</aside>
					</section>
					<section data-background="../img/ball.gif">
						<aside class="notes">
							Выглядит она примерно так:
						</aside>
					</section>
					<section>
						<p>Неизменяемый - значение объекта не может быть изменено после создания</p>
						<p class="fragment">Изменяемый - значение объекта может быть изменено после создания</p>
						<aside class="notes">
							Когда элемент неизменяемый, его значение не может быть изменено после создания. В свою очередь изменяемый элемент изменен быть может.
						</aside>
					</section>
					<section>
						<h4>JavaScript — язык с сильной изменяемостью и состоящий из множества парадигм</h4>
						<aside class="notes">JavaScript — язык с сильной изменяемостью и состоящий из множества парадигм. В отличии от функциональных языков, при написании функционального JavaScript, реализация неизменяемости требует внимательности. Если вы что-то нечаянно модифицируете, JavaScript не станет выбрасывать ошибки. Тестирование и библиотеки могут помочь, но работа с неизменяемостью в JavaScript потребует практики и методологии.</aside>
					</section>
					<section>
						<h3>Плюсы неизменяемости</h3>
						<ul>
							<li>код проще понимать</li>
							<li>персистентность (существование в течении длительного времени)</li>
							<li>возможность хранения более старых версий структур данных</li>
						</ul>
					</section>
					<section>
						<h3>Минус неизменяемости</h3>
						<h6>- многие алгоритмы и операции не могут быть эффективно реализованы</h6>
					</section>
				</section>
				<section>
					<section>
						<h2>Декларативность</h2>
						<aside class="notes">Если мы пишем функциональный код, мы пишем декларативно.</aside>
					</section>
					<section>
						<p>Императивный код - <code>как</code> достичь</p>
						<p>Декларативный код - <code>что</code> достичь</p>
						<aside class="notes">
							Императивный код отвечает на вопрос: «Как достичь результата?». Декларативный код: «Что достичь?».

							Если вы использовали цикл for, вы писали императивный JavaScript. При декларативном написании кода компьютер сам заботится о том, как достичь конечного результата без явного описания этого разработчиком. Если вы использовали Array.map, вы писали декларативный JavaScript.
						</aside>
					</section>
					<section>
						<h2>Императивный код</h2>
<pre><code>function incrementArray(arr) {
	let resultArr = [];
	for (let i = 0; i < arr.length; i++) {
		resultArr.push(arr[i] + 1);
	}
	return resultArr;
}</code></pre>
						<aside class="notes">
							Эта функция описывает логику работы как: мы выполняем обход массива и явно увеличиваем каждое число, помещая его в новый массив. Затем мы возвращаем результирующий массив. Это пошаговое описание логики функции.
						</aside>
					</section>
					<section>
						<h2>Декларативный код</h2>
<pre><code>function incrementArray(arr) {
	return arr.map(item => item + 1);
}</code></pre>
						<aside class="notes">
							Здесь мы показываем, что хотим достичь, но не как это работает. Метод Array.map() возвращает новый массив с результатами выполнения обратного вызова для каждого элемента из переданного массива. Этот подход не изменяет существующие значения и не включает в себя последовательную логику, раскрывающую, как он создает новый массив.
						</aside>
					</section>
					<section>
<pre><code>const multiplyByFive = (x) => 5 * x;

const y = multiplyByFive(4);

// y === 20;</code></pre>
						<aside class="notes">
							Возьмем пример с нашей чистой функцией multiplyByFive. Когда нам нужно умножить 4 на 5, мы не будем указывать как это сделать. Мы просто скажем, что нам нужно умножить на 5 - multiplyByFive - это и есть наш набор действий.
						</aside>
					</section>
					<section data-background="../img/pizza2.gif">
						<aside class="notes">
							А если нам понадобится пицца на крыше, то мы скажем Хайзенбергу что нам нужно, а уж он знает, как это организовать.
						</aside>
					</section>
				</section>
				<section>
					<section>
						<h3>Функции высшего порядка</h3>
						<h6>- функция, принимающая другую функцию в качестве аргумента или возвращающая функцию в результате</h6>
						<aside class="notes">
							Функция высшего порядка - функция, принимающая другую функцию в качестве аргумента или возвращающая функцию в результате.

							В JavaScript функции являются объектами первого класса - элементы, которые могут быть переданы как параметр, возвращены из функции, присвоены переменной. Они могут храниться и передаваться как значения: мы можем присвоить функцию переменной или передать функцию другой функции.
						</aside>
					</section>
					<section>
<pre><code>const double = function(x) {
	return x * 2;
}

const timesTwo = double;

timesTwo(4); // результат: возвращает 8</code></pre>
						<aside class="notes">
							Присваиваем переменной функцию
						</aside>
					</section>
					<section>
<pre><code>function sayHi() {
	alert('Hi!');
}

function greet(greeting) {
	greeting();
}
greet(sayHi); // "Hi!"</code></pre>
						<aside class="notes">
							Обратите внимание, что при передаче именованной функции в качестве аргумента мы не используем круглые скобки `()`. Таким образом мы передаем функцию как объект. Круглые скобки выполняют функцию и передают результат вместо самой функции.
						</aside>
					</section>
					<section>
<pre><code>function whenMeetingJohn() {
	return function() {
		alert('Hi!');
	}
}

var atLunchToday = whenMeetingJohn();

atLunchToday(); // "Hi!"</code></pre>
						<aside class="notes">
							Функции высшего порядка также могут возвращать другую функцию
						</aside>
					</section>
					<section data-background="../img/power.gif">
						<aside class="notes">
							Именно функции высшего порядка делают возможным функциональное программирование в Javascript и они действительно мощны.
						</aside>
					</section>
				</section>
				<section>
					<section>
						<h2>Функциональное программирование</h2>
						<aside class="notes">Подводя итог, можно дать множество определений функционального программирования</aside>
					</section>
					<section>
						<h6>- парадигма программирования, рассматривающая вычисления как вычисления значений функций в математическом понимании последних</h6>
						<aside class="notes">- парадигма программирования, рассматривающая вычисления как вычисления значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном программировании)</aside>
					</section>
					<section>
						<h6>- парадигма, избегающая изменяющихся состояний и данных</h6>
					</section>
					<section>
						<h6>- парадигма программирования, использующая декларативный подход: программирование осуществляется с помощью выражений вместо операторов</h6>
						<aside class="notes">
							парадигма программирования, использующая декларативный подход: программирование осуществляется с помощью выражений (деклараций) вместо операторов
						</aside>
					</section>
					<section>
						<h6>- парадигма, при которой выходное значение функции зависит только от аргументов</h6>
						<aside class="notes">парадигма программирования, при которой выходное значение функции зависит только от аргументов, передаваемых функции, поэтому вызов функции f дважды с тем же значением аргумента x будет каждый раз приводить к одному и тому же результату f(x)</aside>
					</section>
					<section>
						<h6>И, поверьте, это еще не все...</h6>
					</section>
					<section>
						<h2>Минусы</h2>
						<ul>
							<li class="fragment">Требует много памяти</li>
							<li class="fragment">Широко не распространен</li>
						</ul>
						<aside class="notes">
							Минусами функционального программирования можно названия отсутствие широкого распространения на практике и высокие требования к количеству памяти.
						</aside>
					</section>
					<section>
						<h2>Плюсы</h2>
						<ul>
							<li class="fragment">Отсутствие багов</li>
							<li class="fragment">Переиспользование функций</li>
							<li class="fragment">Паралельное исполнение</li>
							<li class="fragment">Производительность</li>
							<li class="fragment">Инкапсуляция логики в чистых функциях</li>
							<li class="fragment">Модульность</li>
							<li class="fragment">Поддержка и понимание</li>
							<li class="fragment">Тестируемость</li>
						</ul>
						<aside class="notes">
							Зато сколько плюсов
						</aside>
					</section>
					<section>
						<h2>Помните,</h2>
						<small>каждая парадигма обладает своими плюсами и минусами, меняющимися в зависимости от задачи</small>
						<aside class="notes">
							Всегда помните, что каждая парадигма обладает своими плюсами и минусами, меняющимися в зависимости от задачи.
						</aside>
					</section>
					<section>
						<h2>Но...</h2>
					</section>
					<section data-background="../img/sherlock.gif">
						<aside class="notes">
							Функциональное программирование все равно круче!
						</aside>
					</section>
				</section>
				<section>
					<h4>Использованная литература <br/>и дополнительная информация</h4>
					<div style="text-align: left;">
						<small><a href="https://medium.com/devschacht/glossary-of-modern-javascript-concepts-1198b24e8f56">Справочник современных концепций JavaScript: часть 1</a></small>
						<small><a href="http://helpmatan.ru/">Функция, производная, графики</a></small>
						<small><a href="https://github.com/MostlyAdequate/mostly-adequate-guide-ru">Mostly adequate guide to FP</a></small>
						<small><a href="https://medium.com/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99">Higher Order Functions (Composing Software)</a></small>
						<small><a href="https://medium.com/javascript-scene/why-learn-functional-programming-in-javascript-composing-software-ea13afc7a257">Why Learn Functional Programming in JavaScript? (Composing Software)</a></small>
						<small><a href="https://github.com/jcouyang/functional-javascript/tree/master/en">Functional JavaScript</a></small>
						<small><a href="http://www.journaldev.com/8693/functional-imperative-object-oriented-programming-comparison">Compare Functional Programming, Imperative Programming and Object Oriented Programming</a></small>
					</div>
				</section>
				<section>
					<h2><i>f </i>(вторник)</h2>
					<br/>
					<div>
						<small><a href="https://medium.com/@maksugr">Роман Пономарев</a></small>
						<small><a href="https://medium.com/@yalovek">Вадим Яловенко</a></small>
					</div>
					<div>
						<small><a href="https://github.com/devSchacht/functional_tuesday">GitHub</a></small>
						<small><a href="https://medium.com/devschacht">Medium</a></small>
					</div>
				</section>
			</div>
		</div>
		<script src="../lib/js/head.min.js"></script>
<script src="../js/reveal.min.js"></script>

<script>
	Reveal.initialize({
		controls: false,
		progress: false,
		history: true,
		center: true,
		transition: 'slide',
		dependencies: [
			{ src: '../lib/js/classList.js', condition: function() { return !document.body.classList; } },
			{ src: '../plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: '../plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: '../plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
			{ src: '../plugin/zoom-js/zoom.js', async: true },
			{ src: '../plugin/notes/notes.js', async: true }
		]
	});
</script>
	</body>
</html>
